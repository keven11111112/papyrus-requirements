/*****************************************************************************
 * Copyright (c) 2017 CEA LIST.
 *
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 * 
 * 		Mauricio Alferez (mauricio.alferez@cea.fr) CEA LIST - Initial API and implementation
 *
 *****************************************************************************/
/*
 * generated by Xtext 2.11.0
 */
package org.eclipse.papyrus.requirements.sysml14.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.papyrus.requirements.sysml14.boilerplateText.BoilerplateTextPackage;
import org.eclipse.papyrus.requirements.sysml14.boilerplateText.If;
import org.eclipse.papyrus.requirements.sysml14.boilerplateText.Model;
import org.eclipse.papyrus.requirements.sysml14.boilerplateText.Requirement;
import org.eclipse.papyrus.requirements.sysml14.boilerplateText.Shall;
import org.eclipse.papyrus.requirements.sysml14.boilerplateText.ShallAllow;
import org.eclipse.papyrus.requirements.sysml14.boilerplateText.ShallNot;
import org.eclipse.papyrus.requirements.sysml14.boilerplateText.ShallNotAllow;
import org.eclipse.papyrus.requirements.sysml14.boilerplateText.Subject;
import org.eclipse.papyrus.requirements.sysml14.boilerplateText.While;
import org.eclipse.papyrus.requirements.sysml14.services.BoilerplateTextGrammarAccess;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class BoilerplateTextSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private BoilerplateTextGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == BoilerplateTextPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case BoilerplateTextPackage.IF:
				sequence_If(context, (If) semanticObject); 
				return; 
			case BoilerplateTextPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case BoilerplateTextPackage.REQUIREMENT:
				sequence_Requirement(context, (Requirement) semanticObject); 
				return; 
			case BoilerplateTextPackage.SHALL:
				sequence_Shall(context, (Shall) semanticObject); 
				return; 
			case BoilerplateTextPackage.SHALL_ALLOW:
				sequence_ShallAllow(context, (ShallAllow) semanticObject); 
				return; 
			case BoilerplateTextPackage.SHALL_NOT:
				sequence_ShallNot(context, (ShallNot) semanticObject); 
				return; 
			case BoilerplateTextPackage.SHALL_NOT_ALLOW:
				sequence_ShallNotAllow(context, (ShallNotAllow) semanticObject); 
				return; 
			case BoilerplateTextPackage.SUBJECT:
				sequence_Subject(context, (Subject) semanticObject); 
				return; 
			case BoilerplateTextPackage.WHILE:
				sequence_While(context, (While) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Prefix returns If
	 *     If returns If
	 *
	 * Constraint:
	 *     (event+=STRING event+=STRING*)
	 */
	protected void sequence_If(ISerializationContext context, If semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     model=Requirement
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BoilerplateTextPackage.Literals.MODEL__MODEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BoilerplateTextPackage.Literals.MODEL__MODEL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getModelAccess().getModelRequirementParserRuleCall_0(), semanticObject.getModel());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Requirement returns Requirement
	 *
	 * Constraint:
	 *     (prefix=Prefix? system=Subject predicate=Predicate)
	 */
	protected void sequence_Requirement(ISerializationContext context, Requirement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Predicate returns ShallAllow
	 *     ShallAllow returns ShallAllow
	 *
	 * Constraint:
	 *     (action=STRING | (entity=STRING actionPerformedByEntity=STRING))
	 */
	protected void sequence_ShallAllow(ISerializationContext context, ShallAllow semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Predicate returns ShallNotAllow
	 *     ShallNotAllow returns ShallNotAllow
	 *
	 * Constraint:
	 *     (action=STRING | (entity=STRING actionPerformedByEntity=STRING))
	 */
	protected void sequence_ShallNotAllow(ISerializationContext context, ShallNotAllow semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Predicate returns ShallNot
	 *     ShallNot returns ShallNot
	 *
	 * Constraint:
	 *     action=STRING
	 */
	protected void sequence_ShallNot(ISerializationContext context, ShallNot semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BoilerplateTextPackage.Literals.PREDICATE__ACTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BoilerplateTextPackage.Literals.PREDICATE__ACTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getShallNotAccess().getActionSTRINGTerminalRuleCall_3_0(), semanticObject.getAction());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Predicate returns Shall
	 *     Shall returns Shall
	 *
	 * Constraint:
	 *     action=STRING
	 */
	protected void sequence_Shall(ISerializationContext context, Shall semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BoilerplateTextPackage.Literals.PREDICATE__ACTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BoilerplateTextPackage.Literals.PREDICATE__ACTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getShallAccess().getActionSTRINGTerminalRuleCall_2_0(), semanticObject.getAction());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Subject returns Subject
	 *
	 * Constraint:
	 *     system=STRING
	 */
	protected void sequence_Subject(ISerializationContext context, Subject semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BoilerplateTextPackage.Literals.SUBJECT__SYSTEM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BoilerplateTextPackage.Literals.SUBJECT__SYSTEM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSubjectAccess().getSystemSTRINGTerminalRuleCall_0(), semanticObject.getSystem());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Prefix returns While
	 *     While returns While
	 *
	 * Constraint:
	 *     state=STRING
	 */
	protected void sequence_While(ISerializationContext context, While semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BoilerplateTextPackage.Literals.WHILE__STATE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BoilerplateTextPackage.Literals.WHILE__STATE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWhileAccess().getStateSTRINGTerminalRuleCall_1_0(), semanticObject.getState());
		feeder.finish();
	}
	
	
}
